//*************************************************************************************************
//*                                 BIGPROJECT 3   MAZE                                           *
//*                              Assignment 3 MAZE PROBLEM                                        *
//*                   Souce Code BY: Mike.Guan in Kaist LIC Program                                  *
//*************************************************************************************************
//*************************************传说中的分割线**********************************************
#include <stdio.h>
#define N 50           //这里定义常量50来进行存储在迷宫中走过的坐标   下面要定义一个新的二维数组来存储坐标数据
void play(int,int);    //该函数是寻找路径使用的函数，这里先进行函数定义声明  后面进行完善该代码
	 int maze1[10][10] =    //定义迷宫数组 该数组中3为入口 0 可通过  2 为墙壁 4 为出口    maze[i][j]
	{
		{2,3,2,2,2,2,2,2,2,2},
		{2,0,0,2,0,0,0,0,0,2},
		{2,2,0,2,0,2,2,2,0,2},
		{2,0,0,2,0,0,0,2,0,2},
		{2,0,2,2,0,2,0,2,0,2},
		{2,0,0,2,0,0,0,2,0,2},
		{2,2,0,2,0,0,2,0,0,2},
		{2,0,0,0,0,0,2,0,2,2},
		{2,0,2,0,2,0,2,0,0,2},
		{2,2,2,2,2,2,2,2,4,2},
	};
	 int maze2[2][N];
	 //      该数组结构 为0行为x坐标  1行表示为y坐标    
	 //   0   X  x1   x2  x3  x4  x5。。。。。。。。。
	 //   1   Y  y1   y2  y3  y4  y5。。。。。。。。。
	 int flag =0;     //该变量为控制循环输出路径条数所用的变量  这里初始化其值为0
	 int control = 0; //使用该变量判断坐标储存的位置
int main()
{

	int i,j;         //i,j 为控制循环变量  其意图是利用数组数据打印出迷宫的形状
	//下面进行初始化记录坐标的数组
    for(i=0;i<2;i++)
	{
	    for(j=0;j<N;j++)
		{
		    *(*(maze2 +i)+j) =0;
		}
	}
	//下面利用嵌套循环打印出迷宫的形状
    printf("Display the maze fllowing: \n");
	for(i=0;i<10;i++)   //外层循环控制行数 和 负责打印换行符     一共有十行  故外层循环循十次
	{
	    for(j=0;j<10;j++)  //内层循环控制数值判断和打印输出符号
		{
			if(*(*(maze1 + i) +j)== 2)//maze1[i][j] == 2
			{
			    printf("■"); //打印迷宫轮廓
			}
			if(*(*(maze1 + i) +j) == 0)
			{

			    printf("  ");
			}
			if(*(*(maze1 + i) +j)== 3) //打印入口为心形
			{
			    printf("%c%c",3,3);
			}
			if(*(*(maze1 + i) +j) == 4)//打印出口为黑桃图形
			{
			    printf("%c%c",6,6);
			}
		}
        printf("\n");//控制换行
	}
	play(1,1);
	return 0;
}
//下面补充寻找路径函数的代码  总体思路为: 循环递归思想
void play(int i,int j)
{     
	    int m,n;  //  函数内部控制循环变量

		*(*(maze1 + i) +j) =6;	//maze1[i][j] = 6; //用6记录走过路程的标识
        maze2[0][control] = i;  //x 的坐标为i
		maze2[1][control] = j;  //y 的坐标为j
		control++;              //记录完成后该变量进行自增     为再次递归记录坐标做铺垫

		if(i == 8 && j ==8)
		{   
			flag++;     //路径变量进行自增
		    printf("Display the road :  this is the %d road.\n",flag);
			printf("\n");
			for(m=0;m<10;m++)
			{
			    for(n=0;n<10;n++)
				{
				    if(*(*(maze1 + m) +n) == 2)
					{
					     printf("■"); //打印迷宫轮廓
					}
					else if (*(*(maze1 + m) +n) == 6 || *(*(maze1 + m) +n) == 3 || *(*(maze1 + m) +n) == 4)
					{
					     printf("◇");
					}else 
					     printf("  ");
				}
				printf("\n");
                
			}
			printf("\n");
			printf("The road coordinate (x,y) is :\n");
			printf("(0,1)--->");
            for(n=0;*(*(maze2 +0) +n);n++)                    //(m=0;maze2[0][m] != 0;m++)
			{
			    printf("(%d,%d)--->",*(*(maze2 +0)+m),*(*(maze2 +1)+m)); //("(%d,%d)--->",maze2[0][m],maze2[1][m]);
			}
			printf("(9,8)");
			printf("\n");
			getchar();

		}

		//向四个方向递归探测迷宫中所有可能存在的情况  试探顺序    右 左 上 下  
		//利用数值判断该点是否可走 若可走则进行递归 若不可走则将该点的数值重新变为0

		if(*(*(maze1 + i) +(j+1)) == 0)    //*(*(maze1 + i) +(j+1))     maze1[i][j+1] == 0
		{
		    play(i,j+1);
          
		}
		if(*(*(maze1 + i) +(j-1)) == 0)
		{
		    play(i,j-1);
		
		}
		if(*(*(maze1 + (i+1)) +j) == 0)
		{
		    play(i+1,j);
	
		}
		if(*(*(maze1 + (i-1)) +j) == 0)
		{
		    play(i-1,j);

		}


        //下面进行判断返回
	
		*(*(maze1 + i) +j) = 0;       //maze1[i][j] =0;  若不可走则将该点的数值重新变为0
		control--;                    //若该点不可走则坐标记录回到上一个点
		*(*(maze2 +0) +control) = 0;  //maze2[0][control] = 0;    若该点不可走把记录的X坐标重置为0
		*(*(maze2 +1) +control) = 0;  //若该点不可走把记录的Y坐标重置为0 

}





              

